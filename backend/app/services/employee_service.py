"""
employee service.

Auto-generated by crud-generate CLI tool.
"""
from typing import List, Optional
from uuid import UUID

from fastapi import HTTPException, status
from sqlalchemy import select, func, and_
from sqlalchemy.orm import joinedload, noload
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.employee import Employee
from app.schemas.employee_schemas import EmployeeCreate, EmployeeUpdate, EmployeeResponse, EmployeeListResponse
from app.schemas.base import PaginationParams
from app.services.base import BaseService


class EmployeeService(BaseService[Employee, EmployeeCreate, EmployeeUpdate, EmployeeResponse]):
    """
    Service for employee operations.
    
    Provides business logic and database operations for Employee entities.
    Inherits standard CRUD operations from BaseService.
    """
    
    def __init__(self, db: AsyncSession):
        """
        Initialize Employee service.
        
        Args:
            db: Database session
        """
        super().__init__(Employee, db, EmployeeResponse)
    
    async def create(
        self,
        obj_in: EmployeeCreate,
        *,
        created_by_id: Optional[UUID] = None,
        commit: bool = True,
    ) -> Employee:
        """
        Create a new employee with validation.
        
        Args:
            obj_in: The employee creation data
            created_by_id: ID of the user creating the employee
            commit: Whether to commit the transaction
        
        Returns:
            The created employee instance
            
        Raises:
            HTTPException: 409 if email already exists
        """
        # Check if email already exists (case-insensitive)
        existing_employee = await self.get_by_email(obj_in.email)
        if existing_employee:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Employee with email '{obj_in.email}' already exists"
            )
        
        # Create the employee using base service method
        return await super().create(obj_in, created_by_id=created_by_id, commit=commit)
    
    async def get_by_email(self, email: str) -> Optional[Employee]:
        """
        Get an employee by their email address (case-insensitive).
        
        Args:
            email: The email address to search for
        
        Returns:
            The employee instance or None if not found
        """
        # Normalize email to lowercase for comparison
        email_lower = email.lower()
        
        stmt = select(Employee).where(
            func.lower(Employee.email) == email_lower,
            Employee.is_deleted == False  # noqa: E712
        ).options(noload(Employee.position)).limit(1)
        
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def update(
        self,
        id: UUID,
        obj_in: EmployeeUpdate,
        *,
        updated_by_id: Optional[UUID] = None,
        commit: bool = True,
    ) -> Optional[Employee]:
        """
        Update an existing employee with validation.
        
        Args:
            id: The employee ID
            obj_in: The employee update data
            updated_by_id: ID of the user updating the employee
            commit: Whether to commit the transaction
        
        Returns:
            The updated employee instance or None if not found
            
        Raises:
            HTTPException: 409 if updated email conflicts with another employee
        """
        # Check if employee exists
        existing_employee = await self.get_by_id(id)
        if not existing_employee:
            return None
        
        # If email is being updated, check for conflicts
        if obj_in.email is not None and obj_in.email.lower() != existing_employee.email.lower():
            conflicting_employee = await self.get_by_email(obj_in.email)
            if conflicting_employee and conflicting_employee.id != id:
                raise HTTPException(
                    status_code=status.HTTP_409_CONFLICT,
                    detail=f"Employee with email '{obj_in.email}' already exists"
                )
        
        # Update using base service method
        return await super().update(id, obj_in, updated_by_id=updated_by_id, commit=commit)
    
    async def get_by_id_with_position(self, id: UUID) -> Optional[Employee]:
        """
        Get employee by ID with position data eagerly loaded.
        
        Uses joinedload to prevent N+1 query problem when accessing position.
        
        Args:
            id: Employee ID
            
        Returns:
            Employee instance with position loaded, or None if not found
        """
        stmt = select(Employee).where(
            Employee.id == id,
            Employee.is_deleted == False  # noqa: E712
        ).options(joinedload(Employee.position))
        
        result = await self.db.execute(stmt)
        return result.unique().scalar_one_or_none()
    
    async def get_list_with_positions(
        self,
        *,
        pagination: PaginationParams,
        position_id: Optional[UUID] = None,
    ) -> EmployeeListResponse:
        """
        Get paginated list of employees with position data eagerly loaded.
        
        Uses joinedload to prevent N+1 query problem when accessing positions.
        
        Args:
            pagination: Pagination parameters
            position_id: Optional filter by position ID
            
        Returns:
            Paginated list of employees with position data
        """
        # Build base query with joinedload for position
        query = select(Employee).options(joinedload(Employee.position))
        
        # Apply soft-delete filter
        query = query.where(Employee.is_deleted == False)  # noqa: E712
        
        # Apply position_id filter if provided
        if position_id is not None:
            query = query.where(Employee.position_id == position_id)
        
        # Get total count
        count_query = select(func.count()).select_from(
            select(Employee.id).where(
                and_(
                    Employee.is_deleted == False,  # noqa: E712
                    Employee.position_id == position_id if position_id is not None else True
                )
            ).subquery()
        )
        result = await self.db.execute(count_query)
        total = result.scalar() or 0
        
        # Apply sorting
        if pagination.sort_by and hasattr(Employee, pagination.sort_by):
            sort_column = getattr(Employee, pagination.sort_by)
            if pagination.sort_order == "desc":
                query = query.order_by(sort_column.desc())
            else:
                query = query.order_by(sort_column.asc())
        else:
            # Default sort by created_at desc
            query = query.order_by(Employee.created_at.desc())
        
        # Apply pagination
        query = query.offset(pagination.skip).limit(pagination.limit)
        
        # Execute query
        result = await self.db.execute(query)
        db_objects = list(result.unique().scalars().all())
        
        # Convert to response schemas
        response_data = [EmployeeResponse.model_validate(obj) for obj in db_objects]
        
        # Return paginated response
        return EmployeeListResponse.create(
            data=response_data,
            total=total,
            page=pagination.page,
            page_size=pagination.page_size,
        )